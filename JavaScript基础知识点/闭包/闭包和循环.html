<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title></title>
    <style media="screen">

    </style>
</head>

<body>
    <button id="button">click</button>
    <script type="text/javascript">
    //错误的, 试图将循环代码移入定义这个闭包的函数之内
    // function constfuncs() {
    //     var funcs = [];
    //     for (var i = 0; i < 5; i++) {
    //         funcs[i] = function () {return i;}
    //     }
    //     return funcs;
    // }
    // var funcs = constfuncs();
    // console.log(funcs[3]());//5
    //错误原因
    //constfuncs()时已经执行了function constfuncs(){}内的语句
    //完后是这样的:
    //funcs[0] = function () {return i;};
    //funcs[1] = function () {return i;};
    //funcs[2] = function () {return i;};
    //funcs[3] = function () {return i;};
    //funcs[4] = function () {return i;};
    //for循环也执行完了, 但f这 5 个function () {return i;}还没有执行(因为后面没有())
    //所以此时 i等于10
    //在执行funcs[5]()时, 才让function () {return i;}(此时i为5)开始执行
    //i老早就等于5了

    // 修正
    // 这个函数(闭包)返回一个总是返回v的函数
    function constfunc(v) {
        return function() {
            return v;
        };
    }
    //创建一个数组来存储函数
    var funcs = [];
    for (var i = 0; i < 5; i++) {funcs[i] = constfunc(i);}
    console.log(funcs[4]()); //=>4


        // 这段代码会以每秒一次的频率输出五次6
        // 因为延迟函数的回调会在循环结束时才执行
        // 只有一个词法作用域
        // for (var i = 0; i <= +5; i++) {
        //     setTimeout(function timer() {
        //         console.log(i);
        //     }, i * 1000);
        // }
        // 虽然拥有了更多的词法作用域
        // 但只是一个什么都没有的作用域
        // 这段代码也会以每秒一次的频率输出五次6
        // for (var i = 0; i <= 5; i++) {
        //     (function() {
        //         setTimeout(function timer() {
        //             console.log(i);
        //         }, i * 1000);
        //     })()
        // }
        // 改进后的最终版
        // for(var i=1;i<=5;i++){
        //     (function(){
        //         var j=i;//需要有自己的变量, 用来在每个迭代中存储
        //         setTimeout(function(){
        //             console.log(j);
        //         },j*1000);
        //     })();
        // }// 正计时 看看和倒计时的区别 待研究和修改
        // for(var i=1;i<=5;i++){
        //         var j=i;//需要有自己的变量, 用来在每个迭代中存储
        //         setTimeout(function(){
        //             j--;
        //             console.log(j);
        //         },j*1000);
        // }// 倒计时 看看和正计时的区别  待研究和修改
        // //或者
        // for (var i = 1; i <= 5; i++) {
        //     (function(j) {
        //         setTimeout(function timer() {
        //             console.log(j);
        //         }, j * 1000);
        //     })(i)
        // }
        //
        // var button = document.getElementById("button");
        // for(var i=1;i<=5;i++){
        //     (function(){
        //         var j = i;
        //         button.addEventListener('click',function (){
        //             console.log(j);
        //         });
        //     })();
        // }//把所有函数绑定在一个事件上了, 因此会出问题

        //摘自javascript高级程序设计
        // function createFunctions() {
        //     var result = new Array();
        //     for (var i = 0; i < 10; i++) {
        //         result[i] = function() {
        //             return i;
        //         }
        //     }
        //     return result;
        // }
        // var result = createFunctions();
        // console.log(result[1]());
        // 在这里, function(){return i;}是一个闭包;大概可以这样说吧
        //闭包只能取得包含函数中任何变量的最后一个值.
        //别忘了闭包所保存的是整个变量对象. 而不是某个特殊的变量
        //每个函数都返回10,因为每个函数作用域链中都保存着createFunctions()函数的活动对象, 所以他们引用的都是同一个变量i
        //当createFunctions函数返回后, 变量i的值是10
        //但是我们可以通过创建另一个匿名函数强制机制让闭包的行为符合预期
        // function createFunctions() {
        //     var result = new Array();
        //     for (var i = 0; i < 10; i++) {
        //         result[i] = function(num) {//定义了一个匿名函数赋给数组, 每次调用时, 传入了变量i
        //             return function(){//创建并返回会了一个访问num的闭包
        //                 return num;
        //             }
        //         }(i);
        //     }
        //     return result;
        // }
        // var result = createFunctions();
        // console.log(result[1]());
        //上面没有把闭包赋值给数组, 而是定义了一个匿名函数
        // 这里的匿名函数有一个参数num, 也就是最终的函数要返回的值
        //在调用每个匿名函数时. 我们传人了变量i.
        //由于函数参数是按值传递的(这句话很重要, 所以就会将变量i的当前值赋值给参数num
        //而在这个匿名函数内部. 又创建并返回会了一个访问num的闭包
        //这样一来, result数组中的每个函数都有自己num变量的一个副本了
        //上面是书中的代码, 我认为下面这种写法也可以
        // function createFunctions() {
        //     var result = new Array();
        //     for (var i = 0; i < 10; i++) {
        //         result[i] = function(num) {
        //                 return num;
        //         }(i);
        //     }
        //     return result;
        // }
        // var result = createFunctions();
        // console.log(result[1]);
        // 以下关于this对象的闭包, 闭包中使用this对象容易出错
        // var name = "The Window";
        // var object = {
        //     name: "My Object",
        //     getNameFunc: function(){
        //         return function(){
        //             return this.name
        //         }
        //     }
        // }
        // console.log(object.getNameFunc()())//"The Window"
        // 以下修改, 这是闭包
        var name = "The Window";
        var object = {
            name: "My Object",
            getNameFunc: function(){
                var that = this;
                return function(){
                    return that.name;
                }
            }
        }
        console.log(object.getNameFunc()())//"My Object"
        //以下修改, 但这不是闭包
        // var name = "The Window";
        // var object = {
        //     name: "My Object",
        //     getName: function(){
        //             return this.name
        //     }
        // }
        // console.log(object.getName())//"My Object"
    </script>
</body>

</html>
