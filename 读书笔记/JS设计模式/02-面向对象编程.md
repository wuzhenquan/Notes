上一章中写的3个对输入框输入的数据校验功能方法, 用了3个函数, 这是一种面向过程的是想方式, 然而在这种方式中, 你会发现无端地在页面中添加了很多全局变量, 而且不利于别人重复使用. 一旦别人使用以前提供的方法, 你就不能轻易地去修改这些方法, 这不利于别人重复使用. 这不利于团队维护, 因此要**面向对象编程**

面向对象编程

- 其中有一个特点 -- **封装**
- 把需要的功能放在一个对象里
- 就是对一些属性和方法的隐藏与暴露(私有属性, 私有方法, 共有属性, 共有方法, 保护方法等等)

#### 封装

其实就是组合使用构造函数模式和原型模式

```javascript
var Book = function(id, bookname, price){
  this.id = id;
  this.bookname = bookname;
  this.price = price;
}
Book.prototype.display = function(){};
var book = new Book(10, 'JavaScript', 50);
console.log(book.bookname);
```

当创建一个函数或者对象时都会为其创建一个原型对象 prototype , 在 prototype  对象中又会像函数中创建 this 一样创建一个 constructor 属性

特权方法   _JS高程P187_

一个错误的例子来解释没有 new 会产生什么样的情况

```javascript
var Book = function(){
  this.title = title;
  this.time = time;
  this.type = type;
}
var book = Book('JavaScript', '2014', 'js');
// 发现错误
console.log(book); // undefined
console.log(window.title); // JavaScript
console.log(window.time); // 2014
console.log(window.type); // js
// 这三个属性怎么添加到 window 上了?
// 在这一步 var book = Book('JavaScript', '2014', 'js');没有了 new, 会在window 上直接执行 Book 这个函数
```

new 关键字的作用可以看作是对当前对象的 this 不停地赋值, 然而例子中没有用 new, 所以就会直接执行这个函数

安全模式, 避免小白忘记添加 new

```javascript
// 以下是安全模式
var Book = function(title, time, type){
  if(this instanceof Book){
  	this.title = title;
    this.time = time;
    this.type = type;
  }else{
  	return new Book(title, time, type);
  }
}
// 自行检测
```

